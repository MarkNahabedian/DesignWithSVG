<html>
  <head>
    <title>Template HTML file using these libraries</title>
    <style type="text/css">

.dimensions  {
             display: block;
             font-weight: heavier;
}
    </style>
    <script type="text/javascript" src="../common/svg_lib.js"></script>
    <script type="text/javascript" src="../common/shaper_origin.js"></script>
    <script type="text/javascript" src="dw6184_fixed_base.js"></script>
    <script type="text/javascript" src="dw6182_plunge_base.js"></script>
    <script type="text/javascript">
//<![CDATA[

var SVG_MARGIN = 0.25;

var GUIDE_GRID_SPACING = 0.5;

var ROUNDED_CORNER_RADIUS = 0.25;

// Diameter of a 1/4 inch fender washer
var WASHER_DIAMETER = 1.0;

var STAR_KNOB_DIAMETER = 1.5;

// Free fit clearance for 1/4 - 20 machine screw.
var SCREW_CLEARANCE = 0.2660;

// There will be a second fence that can be set so that the position
// of the main fence can be set relative to it.
// We need to ensure that the knobs of the two fences don't interfere
// with one another.

// COORDINATE AXES:
// We define two axes so we can talk about orienting aspects of our
// design.
// The A axis runs parallel to the face of the fence.
// The B axis runs perpendicular to it.
// We append the relevant axis name to each dimension to emphasize
// the axis that dimension runs parallel to.
// The 0 position of each axis is at the center of the router spindle.

class SubBaseGeometry {
    constructor() {
        // Dimensions are in inches.
        // Dimensions of metal base expressed as distance from
        // spindle center.  We take the larger of the dw6182 and
        // dw6184 dimensions.
        var base_A = Math.max(BASE_DIAMETER / 2, BASE_TOTAL_WIDTH / 2);
        var base_B = Math.max(BASE_DIAMETER / 2, BASE_TOTAL_DEPTH / 2);
        this.back_edge_B = - base_B - 0.5;
        this.front_edge_B = base_B + 2;
        this.corner_radius = 0.5;
        this.slot_width_A = SCREW_CLEARANCE;
        this.beyond_slot_A = 1;
        this.adjuster_clearance = Math.max(WASHER_DIAMETER, STAR_KNOB_DIAMETER) / 2;
        console.assert(this.beyond_slot_A > this.adjuster_clearance,
                       'beyond_slot must be greater than adjuster_clearance');
        this.half_width_A = base_A + 2 * this.adjuster_clearance +
                            this.slot_width_A + this.beyond_slot_A +
                            // extra width
                            2;
        this.slot_center_A = this.half_width_A - this.beyond_slot_A -
            this.slot_width_A / 2;
        // Our coordinate system is centered on the router spindle.
        // These offsets translate from spindle centric coordinates to
        // SVG coordinates:
        this.x_translate_A = SVG_MARGIN + this.half_width_A;
        this.y_translate_B = SVG_MARGIN + Math.abs(this.back_edge_B);
    }
    
    svgWidth() {
        // Return the value for the width attribute of the SVG element.
        return 2 * (this.half_width_A + SVG_MARGIN);
    }
    
    svgHeight() {
        // Return the value for the height attribute of the SVG element.
        return Math.abs(this.front_edge_B - this.back_edge_B) + 2 * SVG_MARGIN;
    }
    
    updateSVG(svg_elt) {
        setupSVGViewport(svg_elt, 0, 0, this.svgWidth(), this.svgHeight(), 'in');
        var g = document.createElementNS(svgURI, 'g');
        g.setAttribute('transform', 'translate(' +
                       (SVG_MARGIN + this.x_translate_A) + ', ' +
                       (SVG_MARGIN + this.y_translate_B) + ')');
        svg_elt.appendChild(g);
        var left_A = - this.half_width_A;
        var right_A = this.half_width_A;
        var front_B = this.front_edge_B;
        var back_B = this.back_edge_B;
        // Perimeter:
        var pg = document.createElementNS(svgURI, 'g');
        g.appendChild(pg);
        var perimeter = path(g, [
            ['M', left_A + ROUNDED_CORNER_RADIUS, back_B],
            ['H', right_A - ROUNDED_CORNER_RADIUS],
            // Corner
            ['A', ROUNDED_CORNER_RADIUS, ROUNDED_CORNER_RADIUS,
             0.0, false, true,
             right_A, back_B + ROUNDED_CORNER_RADIUS
            ],
            ['V', front_B - ROUNDED_CORNER_RADIUS],
            // Corner
            ['A', ROUNDED_CORNER_RADIUS, ROUNDED_CORNER_RADIUS,
             0.0, false, true,
             right_A - ROUNDED_CORNER_RADIUS, front_B
            ],
            ['H', left_A + ROUNDED_CORNER_RADIUS],
            // Corner
            ['A', ROUNDED_CORNER_RADIUS, ROUNDED_CORNER_RADIUS,
             0.0, false, true,
             left_A, front_B - ROUNDED_CORNER_RADIUS
            ],
            ['V', this.back_edge_B + ROUNDED_CORNER_RADIUS ],
            // Corner
            ['A', ROUNDED_CORNER_RADIUS, ROUNDED_CORNER_RADIUS,
             0.0, false, true,
             left_A + ROUNDED_CORNER_RADIUS, back_B
            ]            
        ]);
        outside_cut(perimeter);
        // dw6184 router base accomodations:
        var bg4 = document.createElementNS(svgURI, 'g');
        g.appendChild(bg4);
        dw6184_base_perimeter(bg4);
        dw6184_center_hole(bg4);
        dw6184_mounting_hole_countersink(bg4, 1, 1);
        dw6184_mounting_hole_countersink(bg4, -1, 1);
        dw6184_mounting_hole_countersink(bg4, -1, -1);
        dw6184_mounting_hole_countersink(bg4, 1, -1);
        dw6184_mounting_hole(bg4, 1, 1);
        dw6184_mounting_hole(bg4, -1, 1);
        dw6184_mounting_hole(bg4, -1, -1);
        dw6184_mounting_hole(bg4, 1, -1);
        // dw6182 router base accomodations:
        var bg2 = document.createElementNS(svgURI, 'g');
        g.appendChild(bg2);
        dw6182_base_extent(bg2);
        dw6182_mounting_hole(bg2, 1, 1);
        dw6182_mounting_hole(bg2, -1, 1);
        dw6182_mounting_hole(bg2, -1, -1);
        dw6182_mounting_hole(bg2, 1, -1);
        // Slots:
        var geo = this;
        var draw_slot = function(direction) {
            var sg = document.createElementNS(svgURI, 'g');
            g.appendChild(sg);
            var slot_outside_edge_A = geo.slot_center_A + geo.slot_width_A;
            var slot = path(sg, [
                ['M',
                 direction * slot_outside_edge_A,
                 geo.back_edge_B + geo.adjuster_clearance - SCREW_CLEARANCE / 2],
                ['V', geo.front_edge_B - geo.adjuster_clearance],
                ['h', - direction * geo.slot_width_A],
                ['V', geo.back_edge_B + geo.adjuster_clearance +  SCREW_CLEARANCE / 2],
                ['h', direction * geo.slot_width_A]
            ]);
            inside_cut(slot);
            guide_line(path(sg, [
                ['M', direction * (slot_outside_edge_A + geo.adjuster_clearance),
                 geo.back_edge_B],
                ['V', geo.front_edge_B]]));
            guide_line(path(sg, [
                ['M', direction * (slot_outside_edge_A -
                                   geo.slot_width_A -
                                   geo.adjuster_clearance),
                 geo.back_edge_B],
                ['V', geo.front_edge_B]]));
        };
        draw_slot(-1);
        draw_slot(1);
        // Add some more guielines just to get a sense of measurement.
        var spacing = GUIDE_GRID_SPACING;
        var g1 = document.createElementNS(svgURI, "g");
        for (var y = 0; y > this.back_edge_B; y -= spacing) {
            guide_line(path(g1, [
                ['M', - this.half_width_A, y],
                ['H', this.half_width_A]
            ]));
        }
        for (var y = spacing; y < this.front_edge_B; y += spacing) {
            guide_line(path(g1, [
                ['M', - this.half_width_A, y],
                ['H', this.half_width_A]
            ]));
        }
        for (var x = 0; x < this.half_width_A; x += spacing) {
            guide_line(path(g1, [
                ['M', x, - spacing / 2],
                ['v', spacing]
            ]));
            guide_line(path(g1, [
                ['M', - x, - spacing / 2],
                ['v', spacing]
            ]));
        }
        g.appendChild(g1);
    }
};


class FenceGeometry {
    constructor(subbaseGeometry) {
        // Dimensions are in inches.
        this.sbg = subbaseGeometry
        this.cutter_clearance_radius = 0.5;
        this.fence_height_B = 1 + this.cutter_clearance_radius;
    }

    svgWidth() {
        // Return the value for the width attribute of the SVG element.
        return this.sbg.svgWidth();
    }
    
    svgHeight() {
        // Return the value for the height attribute of the SVG element.
        return this.fence_height_B + 2 * SVG_MARGIN;
    }

    updateSVG(svg_elt) {
        setupSVGViewport(svg_elt, 0, 0, this.svgWidth(), this.svgHeight(), 'in');
        var g = document.createElementNS(svgURI, 'g');
        g.setAttribute('transform', 'translate(' +
                       (SVG_MARGIN + this.sbg.x_translate_A) + ', ' +
                       SVG_MARGIN + ')');
        var left_A = - this.sbg.half_width_A;
        var right_A = this.sbg.half_width_A;
        var top_B = 0;
        var bottom_B = this.fence_height_B;
        var perimeter = path(g, [
            ['M', left_A + ROUNDED_CORNER_RADIUS, top_B],
            ['H', - this.cutter_clearance_radius],
            // Cutter cutout
            ['A', this.cutter_clearance_radius, this.cutter_clearance_radius,
             0.0, false, false,
             this.cutter_clearance_radius, 0],
            ['H', right_A - ROUNDED_CORNER_RADIUS],
            // corner
            ['A', ROUNDED_CORNER_RADIUS, ROUNDED_CORNER_RADIUS,
             0.0, false, true,
             right_A, top_B + ROUNDED_CORNER_RADIUS],
            ['V', bottom_B - ROUNDED_CORNER_RADIUS],
            // Corner
            ['A', ROUNDED_CORNER_RADIUS, ROUNDED_CORNER_RADIUS,
             0.0, false, true,
             right_A - ROUNDED_CORNER_RADIUS, bottom_B],
            ['H', left_A + ROUNDED_CORNER_RADIUS],
            // Corner
            ['A', ROUNDED_CORNER_RADIUS, ROUNDED_CORNER_RADIUS,
             0.0, false, true,
             - this.sbg.half_width_A, this.fence_height_B - ROUNDED_CORNER_RADIUS],
            ['V', ROUNDED_CORNER_RADIUS],
            // Corner
            ['A', ROUNDED_CORNER_RADIUS, ROUNDED_CORNER_RADIUS,
             0.0, false, true,
             - this.sbg.half_width_A + ROUNDED_CORNER_RADIUS, 0]
        ]);
        outside_cut(perimeter);
        g.appendChild(perimeter);
        svg_elt.appendChild(g);
        // Holes for the positioning hardware
        var geo = this;
        var hole = function(x) {
            var y = geo.fence_height_B / 2;
            var hole = document.createElementNS(svgURI, 'circle');
            hole.setAttribute('cx',   '' + x);
            hole.setAttribute('cy',   '' + y);
            hole.setAttribute('r',   '' + (SCREW_CLEARANCE / 2));
            inside_cut(hole);
            g.appendChild(hole);
            var clearance = document.createElementNS(svgURI, 'circle');
            clearance.setAttribute('cx',   '' + x);
            clearance.setAttribute('cy',   '' + y);
            clearance.setAttribute('r',   '' + geo.sbg.adjuster_clearance);
            guide_line(clearance);
            g.appendChild(clearance);
        };
        hole(this.sbg.slot_center_A);
        hole(- this.sbg.slot_center_A);
        for (var y = GUIDE_GRID_SPACING; y < this.fence_height_B; y += GUIDE_GRID_SPACING) {
            guide_line(path(g, [
                ['M', - this.sbg.half_width_A, y],
                ['H', this.sbg.half_width_A]
            ]));
        }
    }
};


function show_dimensions(parent, subbase, fence) {
    var dimension = function(text) {
        console.log(text);
        var t = document.createElementNS(svgURI, 'p');
        var t1 = document.createTextNode(text);
        t.appendChild(t1);
        parent.appendChild(t);
    };
    dimension('Subbase width: ' + (2 * subbase.half_width_A));
    dimension('Subbase height: ' + (subbase.front_edge_B - subbase.back_edge_B));
    var fence_adjustment_hole_offset = fence.fence_height_B / 2;
    dimension('Fence max back position: ' + (
        subbase.back_edge_B + subbase.adjuster_clearance + fence_adjustment_hole_offset));
    dimension('Fence max front position: ' + (
        subbase.front_edge_B - subbase.adjuster_clearance -fence_adjustment_hole_offset));
    console.log(parent);
}


function contentLoaded() {
    setSVGNamespaces();
    var subbase = new SubBaseGeometry();
    subbase.updateSVG(document.getElementById('SUBBASE_SVG_ELEMENT'));
    showSVG(document.getElementById('SUBBASE_SVG_ELEMENT'),
            document.getElementById('SUBBASE_CODE_ELEMENT'));
    var fence = new FenceGeometry(subbase);
    fence.updateSVG(document.getElementById('FENCE_SVG_ELEMENT'));
    showSVG(document.getElementById('FENCE_SVG_ELEMENT'),
            document.getElementById('FENCE_CODE_ELEMENT'));
    show_dimensions(document.getElementById('DIMENSIONS'),
        subbase, fence);
}

document.addEventListener("DOMContentLoaded", contentLoaded, false);

//]]>

    </script>
  </head>
  <body>

    <h1>Edge Guide Sub-base plate for DeWalt  DW6184 Router Bae</h1>

    <p>
      The design provides two slots to accomodate an adjustable guide
      fence that is mounted and adjusted using 1/4 - 20 machine screws
      or carriage bolts and wingnuts or star knobs.
    </p>

    <p>
      We also inclue accomodation for a second fence that can be set
      to a position and have the primary fence adjusted relative to.
      For example, one might set the secondary fence to butt against
      the cutter, position the primary fence based on the secondary
      feence and a spacer block, and then remove the secondary fence.
    </p>

    <p>
      We assume the fence has a notch cut into it that is big enoughto
      clear a 1/5 inch cutter.
    </p>

    <h2>Dimensions</h2>
    <div id="DIMENSIONS" class="dimensions"></div> 

    <h2>Subbase</h2>
    <div>
      <pre id="SUBBASE_CODE_ELEMENT"> 
      </pre>
      <svg id="SUBBASE_SVG_ELEMENT"></svg>
    </div>

    <h2>Fence</h2>
    <div>
      <pre id="FENCE_CODE_ELEMENT"> 
      </pre>
      <svg id="FENCE_SVG_ELEMENT"></svg>
    </div>

  </body>
</html>
