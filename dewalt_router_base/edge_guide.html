<html>
  <head>
    <title>Template HTML file using these libraries</title>
    <script type="text/javascript" src="../common/svg_lib.js"></script>
    <script type="text/javascript" src="../common/shaper_origin.js"></script>
    <script type="text/javascript" src="dw6184_fixed_base.js"></script>
    <script type="text/javascript">
//<![CDATA[

var SVG_MARGIN = 0.25;

// Diameter of a 1/4 inch fender washer
var WASHER_DIAMETER = 1.0;

var STAR_KNOB_DIAMETER = 1.5;

// Free fit clearance for 1/4 - 20 machine screw.
var SCREW_CLEARANCE = 0.2660;

// There will be a second fence that can be set so that the position
// of the main fence can be set relative to it.
// We need to ensure that the knobs of the two fences don't interfere
// with one another.

// COORDINATE AXES:
// We define two axes so we can talk about orienting aspects of our
// design.
// The A axis runs parallel to the face of the fence.
// The B axis runs perpendicular to it.
// We append the relevant axis name to eaach dimension to emphasize
// the axis that dimension runs parallel to.
// The 0 position of each axis is at the center of the router spindle.

class SubBaseGeometry {
    constructor() {
        // Dimensions are in inches.
        var base_radius = BASE_DIAMETER / 2;
        this.back_edge_B = - base_radius - 0.5;
        this.front_edge_B = base_radius + 2;
        this.corner_radius = 0.5;
        this.slot_width_A = SCREW_CLEARANCE;
        this.beyond_slot_A = 1;
        this.adjuster_clearance = Math.max(WASHER_DIAMETER, STAR_KNOB_DIAMETER) / 2;
        console.assert(this.beyond_slot_A > this.adjuster_clearance,
                       'beyond_slot must be greater than adjuster_clearance');
        this.half_width_A = base_radius + 2 * this.adjuster_clearance +
                            this.slot_width_A + this.beyond_slot_A +
                            // extra width
                            2;
        this.slot_center_A = this.half_width_A - this.beyond_slot_A -
            this.slot_width_A / 2;
        // Our coordinate system is centered on the router spindle.
        // These offsets translate from spindle centric coordinates to
        // SVG coordinates:
        this.x_translate_A = SVG_MARGIN + this.half_width_A;
        this.y_translate_B = SVG_MARGIN + Math.abs(this.back_edge_B);
    }
    
    svgWidth() {
        // Return the value for the width attribute of the SVG element.
        return 2 * (this.half_width_A + SVG_MARGIN);
    }
    
    svgHeight() {
        // Return the value for the height attribute of the SVG element.
        return Math.abs(this.front_edge_B - this.back_edge_B) + 2 * SVG_MARGIN;
    }
    
    updateSVG(svg_elt) {
        setupSVGViewport(svg_elt, 0, 0, this.svgWidth(), this.svgHeight(), 'in');
        var g = document.createElementNS(svgURI, 'g');
        g.setAttribute('transform', 'translate(' +
                       (SVG_MARGIN + this.x_translate_A) + ', ' +
                       (SVG_MARGIN + this.y_translate_B) + ')');
        svg_elt.appendChild(g);
        // Perimeter:
        var perimeter = path(g, [
            ['M', - this.half_width_A, this.back_edge_B],
            ['H', this.half_width_A],
            ['V', this.front_edge_B],
            ['H', - this.half_width_A],
            ['V', this.back_edge_B],
        ]);
        outside_cut(perimeter);
        // Router base accomodations:
        dw6184_base_perimeter(g);
        dw6184_center_hole(g);
        dw6184_mounting_hole(g, 1, 1);
        dw6184_mounting_hole(g, -1, 1);
        dw6184_mounting_hole(g, -1, -1);
        dw6184_mounting_hole(g, 1, -1);
        // Slots:
        var geo = this;
        var draw_slot = function(direction) {
            var slot_outside_edge_A = geo.slot_center_A + geo.slot_width_A;
            var slot = path(g, [
                ['M',
                 direction * slot_outside_edge_A,
                 geo.back_edge_B + geo.adjuster_clearance],
                ['V', geo.front_edge_B - geo.adjuster_clearance],
                ['h', - direction * geo.slot_width_A],
                ['V', geo.back_edge_B + geo.adjuster_clearance],
                ['h', direction * geo.slot_width_A]
            ]);
            inside_cut(slot);
            guide_line(path(g, [
                ['M', direction * (slot_outside_edge_A + geo.adjuster_clearance),
                 geo.back_edge_B],
                ['V', geo.front_edge_B]]));
            guide_line(path(g, [
                ['M', direction * (slot_outside_edge_A -
                                   geo.slot_width_A -
                                   geo.adjuster_clearance),
                 geo.back_edge_B],
                ['V', geo.front_edge_B]]));
        };
        draw_slot(-1);
        draw_slot(1);
        // Add some more guielines just to get a sense ofmeasurement.
        var spacing = 0.5;
        var g1 = document.createElementNS(svgURI, "g");
        for (var y = 0; y > this.back_edge_B; y -= spacing) {
            guide_line(path(g1, [
                ['M', - this.half_width_A, y],
                ['H', this.half_width_A]
            ]));
        }
        for (var y = spacing; y < this.front_edge_B; y += spacing) {
            guide_line(path(g1, [
                ['M', - this.half_width_A, y],
                ['H', this.half_width_A]
            ]));
        }
        for (var x = 0; x < this.half_width_A; x += spacing) {
            guide_line(path(g1, [
                ['M', x, - spacing / 2],
                ['v', spacing]
            ]));
            guide_line(path(g1, [
                ['M', - x, - spacing / 2],
                ['v', spacing]
            ]));
        }
        g.appendChild(g1);
    }
};


class FenceGeometry {
    constructor(subbaseGeometry) {
        // Dimensions are in inches.
        this.sbg = subbaseGeometry
        this.cutter_clearance_radius = 0.5;
        this.fence_height_B = 1 + this.cutter_clearance_radius;
    }

    svgWidth() {
        // Return the value for the width attribute of the SVG element.
        return this.sbg.svgWidth();
    }
    
    svgHeight() {
        // Return the value for the height attribute of the SVG element.
        return this.fence_height_B + 2 * SVG_MARGIN;
    }

    updateSVG(svg_elt) {
        setupSVGViewport(svg_elt, 0, 0, this.svgWidth(), this.svgHeight(), 'in');
        var g = document.createElementNS(svgURI, 'g');
        g.setAttribute('transform', 'translate(' +
                       (SVG_MARGIN + this.sbg.x_translate_A) + ', ' +
                       SVG_MARGIN + ')');
        var perimeter = path(g, [
            ['M', - this.sbg.half_width_A, 0],
            ['H', - this.cutter_clearance_radius],
            ['A', this.cutter_clearance_radius, this.cutter_clearance_radius,
             0.0, false, false,
             this.cutter_clearance_radius, 0],
            ['H', this.sbg.half_width_A],
            ['V', this.fence_height_B],
            ['H', - this.sbg.half_width_A],
            ['V', 0]
        ]);
        outside_cut(perimeter);
        g.appendChild(perimeter);
        svg_elt.appendChild(g);
        // Holes for the positioning hardware
        var geo = this;
        var hole = function(x) {
            var hole = document.createElementNS(svgURI, 'circle');
            hole.setAttribute('cx',   '' + x);
            hole.setAttribute('cy',   '' + (geo.fence_height_B / 2));
            hole.setAttribute('r',   '' + (SCREW_CLEARANCE / 2));
            inside_cut(hole);
            g.appendChild(hole);
        };
        hole(this.sbg.slot_center_A);
        hole(- this.sbg.slot_center_A);
    }
};


function contentLoaded() {
    setSVGNamespaces();
    var subbase = new SubBaseGeometry();
    subbase.updateSVG(document.getElementById('SUBBASE_SVG_ELEMENT'));
    showSVG(document.getElementById('SUBBASE_SVG_ELEMENT'),
            document.getElementById('SUBBASE_CODE_ELEMENT'));
    var fence = new FenceGeometry(subbase);
    fence.updateSVG(document.getElementById('FENCE_SVG_ELEMENT'));
    showSVG(document.getElementById('FENCE_SVG_ELEMENT'),
            document.getElementById('FENCE_CODE_ELEMENT'));
}

document.addEventListener("DOMContentLoaded", contentLoaded, false);

//]]>

    </script>
  </head>
  <body>

    <h1>Edge Guide Sub-base plate for DeWalt  DW6184 Router Bae</h1>

    <p>
      The design provides two slots to accomodate an adjustable guide
      fence that is mounted and adjusted using 1/4 - 20 machine screws
      or carriage bolts and wingnuts or star knobs.
    </p>

    <p>
      We also inclue accomodation for a second fence that can be set
      to a position and have the primary fence adjusted relative to.
      For example, one might set the secondary fence to butt against
      the cutter, position the primary fence based on the secondary
      feence and a spacer block, and then remove the secondary fence.
    </p>

    <p>
      We assume the fence has a notch cut into it that is big enoughto
      clear a 1/5 inch cutter.
    </p>

    <h2>Subbase</h2>
    <div>
      <pre id="SUBBASE_CODE_ELEMENT"> 
      </pre>
      <svg id="SUBBASE_SVG_ELEMENT"></svg>
    </div>

    <h2>Fence</h2>
    <div>
      <pre id="FENCE_CODE_ELEMENT"> 
      </pre>
      <svg id="FENCE_SVG_ELEMENT"></svg>
    </div>

  </body>
</html>
